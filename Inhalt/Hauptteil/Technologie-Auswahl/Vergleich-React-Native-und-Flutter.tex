\clearpage
\section{Vergleich von \enquote{React Native} und \enquote{Flutter}}
\label{sec:Vergleich-React-Native-und-Flutter}


Es soll eine Formularanwendung mit komplexer Validierung im Rahmen dieser These erstellt werden.
Es ist durchaus sinnvoll, die beiden Technologien anhand von  Beispielanwendungen, welche Formulare und die Validierung dieser  beinhalten,   zu vergleichen.
Deshalb soll nachfolgend  jeweils eine solche Beispielanwendung der jeweiligen Technologie gefunden werden.
Die Anwendungen werden sich stark voneinander unterscheiden, weshalb sie im nächsten Schritt vereinfacht und aneinander angeglichen werden.
Anschließend wird ersichtlich, nach welchen Kriterien sich die Technologien im Hinblick auf die Entwicklung der Formularanwendung vergleichen lassen.

\subsection{Vergleich zweier minimaler Beispiele für Formulare und Validierung}

\subsubsection{Formulare in \enquote{React Native}}

\enquote{React Native} stellt nur eine vergleichsweise geringe Anzahl von eigenen Komponenten zur Verfügung und zu diesen gehören keine, welche die Validierung von Formularen ermöglichen.
Doch die im \enquote{react.js} Raum sehr bekannten Bibliotheken \enquote{Formic}, \enquote{Redux Forms} und \enquote{React Hook Form} sind alle drei kompatibel mit \enquote{React Native}.
\footcite[Vgl.][]{ReactNativeFormikDocs}\textsuperscript{,}\footcite[Vgl.][]{DoesReduxFormWorkWithReactNative}\textsuperscript{,}\footcite[Vgl.][]{ReactNativeReactHookFormGetStarted}


Für die Formularanwendung ist die Validierung komplexer Bedingungen nötig.
Die Formular-Validierungs-Bibliotheken bieten in der Regel Funktionen an, welche überprüfen, ob ein Feld gefüllt ist oder der Inhalt einem speziellen Muster entspricht -- wie etwa einem regulären Ausdruck.
Doch solche mitgelieferten Validierungs-Funktionen reichen nicht aus, um die Komplexität der Bedingungen abzubilden.
Stattdessen müssen benutzerdefinierte Funktionen zum Einsatz kommen.

Keine der drei oben genannten Validierungs-Bibliotheken ist in dieser Hinsicht limitiert.
Sie alle bieten die Möglichkeit, eine \enquote{JavaScript}-Funktion für die Validierung zu übergeben.
Diese Funktion gibt einen Wahrheitswert zurück -- wahr, wenn das Feld oder die Felder valide sind, falsch, falls nicht.
In \enquote{React Hook Form} ist es die Funktion \enquote{register}, die ein Parameterobjekt namens \enquote{RegisterOptions} erhält.
Der Eigenschaft \enquote{validate} dieses Objektes kann eine \enquote{JavaScript}-Funktion für die Validierung übergeben werden.\footcite[Vgl.][]{RegisterReactHookFormAPI}
In \enquote{Redux Form} ist es die Initialisierungs-Funktion \enquote{reduxForm}, die ein Konfigurations-Objekt mit dem Namen \enquote{config} erhält, in welchem die Eigenschaft ebenfalls \enquote{validate} heißt.\footcite[Vgl.][]{ReduxFormReduxFormAPI}
Auch in \enquote{Formic} ist der Bezeichner \enquote{validate}, und ist als Attribut in der \enquote{Formic}-Komponente  zu finden.\footcite[Vgl.][]{FormikComponentFormikDocsAPI}


Es ist also absehbar, dass die Formularanwendung in \enquote{React Native} entwickelt werden kann.
Die nötigen Funktionen werden von den Bibliotheken bereitgestellt.
Einziger Nachteil hierbei ist, dass es sich um Drittanbieter-Bibliotheken handelt, welche im Verlauf der Zeit an Beliebtheit gewinnen und verlieren können.
Möglicherweise geht die Beliebtheit einer der Bibliotheken mit der Zeit zurück, weshalb es weniger Kontributionen wie etwa neue Funktionalitäten oder Fehlerbehebungen 
sowie Fragen, Antworten und Anleitungen zu diesen Bibliotheken geben wird, da die Entwickler sich für andere Bibliotheken entscheiden.
Die Wahl der Bibliothek kann also schwerwiegende Folgen wie Mangel an Dokumentation oder Limitationen im Vergleich zu anderen Bibliotheken mit sich bringen.
Eine Migration von der einen Bibliothek zu einer anderen könnte in Zukunft notwendig werden, wenn diese Limitationen während der Entwicklung auffallen.
Aus dem Grund ist es in der Regel von Vorteil, wenn solche Funktionalitäten bereits im Kern der Frontend-Technologie integriert sind.
Der Fall, dass die Kernkomponenten an Relevanz verlieren und empfohlen wird, auf externe Bibliotheken zuzugreifen, ist zwar nicht ausgeschlossen, geschieht aber im Wesentlichen seltener.

Für den Vergleich wurde eine Schritt-für-Schritt-Anleitung zum Erstellen eines Formulars mit \enquote{React Hook Form} ausgewählt. \footnoteL{\url{https://dev.to/elaziziyoussouf/forms-in-react-native-the-right-way-4d46}} 


\subsubsection{Formulare in \enquote{Flutter}}
Die \enquote{Flutter}-Dokumentation stellt in ihrer \enquote{cookbook}-Sektion ein Beispiel einer minimalistischen Formularanwendung mit Validierung bereit.\footcite[Vgl.][]{BuildAFormWithValidation}
Das Rezept ist Teil einer Serie von insgesamt fünf Anleitungen, welche Formulare in \enquote{Flutter} behandeln.\footcite[Vgl.][]{FormsFlutter}

Die Rezepte wurden genutzt,
um eine Formularanwendung zu implementieren,
welche dem Ergebnis der \enquote{React Hook Form}-Applikation in Funktionalität und Layout ähnlich ist.

\clearpage
\subsubsection{Ergebnisse des Vergleiches}


Abbildung \ref{fig:Vergleich} zeigt die \enquote{Flutter}-Anwendung (links) und die \enquote{React Native}-Anwendung (rechts).


\begin{alexfigure}{Inhalt/Hauptteil/Technologie-Auswahl/Vergleich.png}
   {Gegenüberstellung der minimalistischen {Flutter}- und \enquote{React Native}-For\-mu\-lar\-ap\-pli\-ka\-ti\-on\-en}
   {Gegenüberstellung der minimalistischen {Flutter}- und \enquote{React Native}-For\-mu\-lar\-ap\-pli\-ka\-ti\-on\-en}
 
   \label{fig:Vergleich}
 
 \end{alexfigure}

 Die Listings \ref{lst:VergleichFlutterValidation} und \ref{lst:VergleichFlutterMain}
 des \enquote{Flutter}-Formulars sind in Anhang \ref{chap:VergleichFlutter}
 auf den Seiten \pageref{lst:VergleichFlutterValidation} und \pageref{lst:VergleichFlutterMain} zu finden.
 Anhang \ref{chap:VergleichReactNatveApp} beinhaltet die Listings
 \ref{lst:VergleichReactNatveApp}, \ref{lst:VergleichReactNatveHero}, \ref{lst:VergleichReactNatveValidation},
 \ref{lst:VergleichReactNatveForm},  \ref{lst:VergleichReactNatveForm2} und \ref{lst:VergleichReactNatveInput} 
 der \enquote{React Hook Form}-Anwendung auf den Seiten \pageref{lst:VergleichReactNatveApp} bis \pageref{lst:VergleichReactNatveInput}.


Folgende Unterschiede waren bei der Untersuchung beider Applikationen auffällig:
\begin{itemize}[topsep=0pt,itemsep=-1ex,partopsep=1ex,parsep=1ex]
   \item Die Anzahl der benötigten Quelltextzeilen unterscheidet sich stark.
   \item \enquote{Flutter}-\enquote{Widgets} bringen ohne zusätzliche Konfiguration bereits ein ansprechendes Aussehen mit. \enquote{React Native} Anwendungen müssen dafür mit zusätzlichen Stylesheets ausgestattet werden. 
\end{itemize}

Tabelle \ref{table:Vergleich} auf Seite \pageref{table:Vergleich} stellt die Anzahl der Quelltextzeilen der unterschiedlichen Anwendungen auf Dateiebene gegenüber. 

\begin{table}
   \ifIncludeFigures

   \begin{tabularx}{\textwidth}{|*{4}{Y|}}
      \hline
      \multirow{3}{*}{Flutter} &\multicolumn{2}{c|}{main.dart}&60   \\
      \cline{2-4}  &\multicolumn{2}{c|}{validation.dart}&15   \\
      \cline{2-4}  &\multicolumn{2}{c|}{\textbf{Summe}}&\textbf{75}   \\
      \cline{1-4}
      \multirow{11}{*}{React Native} &\multirow{6}{*}{Programmcode}  & App.tsx &15\\
      \cline{3-4}  & &Hero.tsx&9\\
      \cline{3-4}  & &Input.tsx&17\\
      \cline{3-4}  & &Form.tsx&52\\
      \cline{3-4}  & &validation.tsx&12\\
      \cline{3-4}  & &\textbf{Summe}&\textbf{112}\\
   
      \cline{2-4}  &\multirow{4}{*}{Stylesheets}  &App.tsx&14\\
      \cline{3-4}  & &Hero.tsx&17\\
      \cline{3-4}  & &Input.tsx&24\\
      \cline{3-4}  & &\textbf{Summe}&\textbf{55}\\
   
   
   
   
      \cline{2-4}  &\multicolumn{2}{c|}{\textbf{Summe}}&\textbf{167}\\
   
   
      \hline
      \end{tabularx}

   \fi

   \caption{Anzahl der Quelltextzeilen der minimalistischen \enquote{Flutter} und \enquote{React Native}-Formular-Applikationen.    }
   \label{table:Vergleich}
   \end{table} 


Kommentare, leere Zeilen und \enquote{import}-Anweisungen wurden bei der Untersuchung ignoriert.
Es wurde kein Versuch unternommen,
den Quellcode der \enquote{React Native}-Applikation zu refaktorisieren,
sodass auch dieser die minimal nötige Anzahl von Zeilen aufweist.
Die allgemeine Anzahl der Quelltext-Zeilen ist für die Evaluierung der Technologie deshalb zweitrangig.

Vor dem Hintergrund,
dass die Wissenschaftler und Wissenschaftlerinnen des Thünen-Instituts keine Anforderungen an das Aussehen der Oberfläche stellen,
soll sich für die Technologie entschieden werden,
welche den Aufwand für das Gestalten der Oberfläche gering hält.
In diesem Fall ist das \enquote{Flutter},
da es in der Standardkonfiguration bereits ein ansprechendes Design mitbringt.
Die \enquote{React Native}-Applikation benötigte dagegen mit 55 Zeilen in den \enquote{Stylesheets} bereits 73 \% der Zeilenanzahl,
die insgesamt für die Entwicklung des Formulars in \enquote{Flutter} nötig waren.

 


\subsection{Automatisiertes Testen}

Um die Codequalität zu gewährleisten,
sollen bei der Entwicklung Unit- und Integrationstests zum Einsatz kommen.
Im Folgenden sollen die Frameworks \enquote{Flutter} und \enquote{React Native} im Hinblick auf die Dokumentation zu diesen Themen untersucht werden. 


\subsubsection{Automatisierte Tests in \enquote{React Native}} Die \enquote{React Native}-Dokumentation führt genau eine Seite mit einem Überblick über die unterschiedlichen Testarten.
Dabei wird das Konzept von Unittests, \enquote{Mocking}, Integrationstests, Komponententests und \enquote{Snapshot}-Tests kurz erläutert, jedoch ohne ein Beispiel zu geben oder zu verlinken.
Vier Quellcodeschnipsel sind auf der Seite zu finden: Ein Schnipsel zeigt den minimalen Aufbau eines Tests; zwei weitere Schnipsel veranschaulichen beispielhaft, wie Nutzerinteraktionen getestet werden können.
Letzteres zeigt die textuelle Repräsentation der Ausgabe einer Komponente, die für einen \enquote{Snapshot}-Test verwendet wird.
Weiterhin wird auf die \enquote{Jest}-API-Dokumentation verwiesen sowie auf ein Beispiel für einen \enquote{Snapshot}-Test in der \enquote{Jest}-Dokumentation.\footnoteL{\url{https://jestjs.io/docs/snapshot-testing}}

Um die notwendigen Anleitungen für das Erstellen der jeweiligen Tests ausfindig zu machen, ist es notwendig, die Dokumentation von \enquote{React Native} zu verlassen.

Die Dokumentation von \enquote{Jest} enthält mehr Details zum Einsatz der Testbibliothek, welche für mehrere Frontend-Frameworks kompatibel ist,
die auf \enquote{JavaScript} basieren\footnoteL{\url{https://jestjs.io/docs/getting-started}}.
Somit muss zum Erstellen der Unittests immerhin nur dieses Framework studiert werden.

Zum Entwickeln von Tests für \enquote{React Native}-Komponenten wird unter anderem auf die Bibliothek \enquote{React Native Testing Library} verwiesen.
Anders als der Name vermuten lässt, handelt es sich nicht um eine von \enquote{React Native} bereitgestellte Bibliothek.
Im Unterschied zur \enquote{React Testing Library}, von der sie inspiriert ist, läuft sie -- so wie \enquote{React Native} auch -- nicht in einer Browser-Umgebung.\footcite[Vgl.][]{NativeTestingLibraryIntroduction}
Herausgegeben wird die \enquote{React Native Testing Library} vom Drittanbieter \enquote{Callstack} -- einem Partner im \enquote{React Native}-Ökosystem.\footcite[Vgl.][]{TheReactNativeEcosystem}

Sie verwendet im Hintergrund den \enquote{React Test Renderer}\footnoteL{\url{https://reactjs.org/docs/test-renderer.html}}, welcher wiederum vom \enquote{React}-Team angeboten wird und auch zum Testen von \enquote{react.js} Anwendungen geeignet ist.
Der \enquote{React Test Renderer} wird ebenfalls empfohlen, um Komponententests zu kreieren, die keine \enquote{React Native} spezifischen Funktionalitäten nutzen.

Um Integrationstests zu entwickeln -- welche die Applikation auf einem physischen Gerät oder auf einem Emulator testen -- wird auf zwei weitere Drittanbieter-Bibliotheken verlinkt:
\enquote{Appium}\footnoteL{\url{http://appium.io/}} und \enquote{Detox}\footnoteL{\url{https://github.com/wix/detox/}}.
Es wird darauf hingewiesen, dass \enquote{Detox} speziell für die Entwicklung von \enquote{React Native}-Integrationstests entwickelt wurde.
\enquote{Appium} wird lediglich als ein weiteres bekanntes Werkzeug erwähnt.

Es lässt sich damit zusammenfassen, dass der Aufwand der Einarbeitung für automatisiertes Testen in \enquote{React Native} vergleichsweise hoch ist.
Die Dokumentation ist auf die Seiten der jeweiligen Anbieter verteilt.
Der Entwickler muss sich den Überblick selbst verschaffen und zusätzlich die für das Framework \enquote{React Native} relevanten Inhalte identifizieren.
Notwendig ist auch das Erlernen von mehreren APIs, um alle Testarten abzudecken.
Für einen Anfänger kommt erschwerend hinzu, dass eine Entscheidung für die eine oder andere Bibliothek notwendig wird.
Um diese Entscheidung treffen zu können, ist eine Auseinandersetzung mit den Vor- und Nachteilen der Technologien im Vorfeld vom Entwickler zu leisten.

\subsubsection{Automatisierte Tests in \enquote{Flutter}}
Die \enquote{Flutter}-Dokumentation erklärt sehr umfangreich auf 11 Unterseiten die unterschiedlichen Testarten mit Quellcodebeispielen
und verlinkt für jede Testart auf eine oder mehrere detaillierte Schritt-für-Schritt-Anleitungen,
wie ein solcher Test erstellt wird.


Eine Seite erklärt den Unterschied zwischen Unittests, \enquote{Widget}-Tests und Integrationstests\footnoteL{\url{https://flutter.dev/docs/testing}}.
Eine weitere Seite erklärt Integrationstests detaillierter\footnoteL{\url{https://flutter.dev/docs/testing/integration-tests}}.

Ein sogenanntes \enquote{Codelab} führt durch die Erstellung einer minimalistischen App und der anschließenden Implementierung von zwei Unit-, fünf \enquote{Widget}- und zwei Integrationstests für diese App\footnoteL{\url{https://codelabs.developers.google.com/codelabs/flutter-app-testing}}.

\clearpage
Im sogenannten Kochbuch tauchen folgende Rezepte auf:

\begin{itemize}[topsep=0pt,itemsep=-1ex,partopsep=1ex,parsep=1ex]
    \item 2 Rezepte für Unittests
    \begin{itemize} 
       \item eine grundlegende Anleitung zum Erstellen von Unittests \footnoteL{\url{https://flutter.dev/docs/cookbook/testing/unit/introduction}}
       \item Eine weitere Anleitung zum Nutzen von \enquote{Mocks} in Unittest mithilfe der Bibliothek \enquote{mockito} \footnoteL{\url{https://flutter.dev/docs/cookbook/testing/unit/mocking}}
    \end{itemize}
    \item 3 Rezepte für \enquote{Widget}-Tests
    \begin{itemize} 
        \item Eine grundlegende Anleitung zum Erstellen von \enquote{Widget}-Tests \footnoteL{\url{https://flutter.dev/docs/cookbook/testing/widget/introduction}}
        \item Ein Rezept mit detaillierteren Beispielen zum Finden von \enquote{Widgets}  zur Laufzeit eines \enquote{Widget}-Tests \footnoteL{\url{https://flutter.dev/docs/cookbook/testing/widget/finders}}
        \item Ein Rezept zum Testen vom Nutzerverhalten wie dem Tab, dem Drag und dem Eingeben von Text \footnoteL{\url{https://flutter.dev/docs/cookbook/testing/widget/tap-drag}}
     \end{itemize}
    \item 3 Rezepte für Integrationstests
    \begin{itemize} 
        \item Eine grundlegende Anleitung zum Erstellen eines Integrationstests \footnoteL{\url{https://flutter.dev/docs/cookbook/testing/integration/introduction}}
        \item eine Anleitung zum Simulieren des Scrollens in der Anwendung während der Laufzeit eines Integrationstests \footnoteL{\url{https://flutter.dev/docs/cookbook/testing/integration/scrolling}}
        \item eine Anleitung zum Performance-Profiling \footnoteL{\url{https://flutter.dev/docs/cookbook/testing/integration/profiling}}
     \end{itemize}
\end{itemize}


