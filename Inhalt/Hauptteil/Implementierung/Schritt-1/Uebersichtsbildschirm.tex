
\ifIncludeFigures \clearpage \fi
\section{Übersichtsbildschirm der Maßnahmen}

Der erste Bildschirm -- die Übersicht der Maßnahmen -- kann auf das im letzten Schritt erstellte \enquote{Model} zugreifen.
In Listing \ref{lst:Schritt1KlasseMassnahmenMasterScreenStruktur}  ist die Struktur des Übersichts-Bildschirms zu sehen. Über die Route \url{/massnahmen_master} ist der Bildschirm erreichbar \Z{16}. Die \IC{build}-Methode zeichnet die Oberfläche \IC{21-111}.  Da ein Objekt des Typs
MassnahmenPool im zentralen  Register der Provider hinterlegt wurde, kann mit der Methode Provider.of darauf zugegriffen werden.

Mittels \IC{AppState.of(context)} ist nun der Zugriff auf sowohl \enquote{Model} als auch \enquote{ViewModel} möglich. Zur einfacheren Verwendung sind sie als lokale Variablen zwischengespeichert \Z{20-21}.

Das Widget \IC{Scaffold} -- deutsch Gerüst --  stell  ein grundlegendes Layout mit einer Überschrift und einem Bereich für den Inhalt bereit \Z{23}.
Das \IC{Scaffold} kann auch Mitteilungen an den Benutzer am unteren Bildschirmrand einblenden.

Die Überschrift wird in der sogenannten \IC{AppBar} hinterlegt \Z{24}.
Sie unterstützt weitere Funktionalitäten.
Sollte es sich bei der aktuell besuchten Route  um eine Unterseite handeln, taucht links von der Titel-Überschrift einen Button zum Zurücknavigieren auf.
Weiterhin können rechts von der Titelleiste Aktionsbuttons hinzugefügt werden. Das ist für die Formularanwendung allerdings nicht nötig.

Zusätzlich kann dem \IC{Scaffold} ein Button für die primäre Aktion auf diesem Bildschirm hinzugefügt werden: der sogenannte \IC{FloatingActionButton} \Z{88-97}.
Bei Aktivierung dieses Buttons navigiert die Applikation zur Eingabemaske, um eine neue Maßnahme anzulegen \Z{98}.

Das Eingabeformular sollte den Benutzer auffordern, tatsächlich leere Eingabefelder zu füllen.
Deshalb muss die Aktivierung des Buttons auch das \enquote{ViewModel} neu initialisieren.
Dies geschieht durch Zuweisung einer leeren Maßnahme zur Setter-Methode \IC{vm.model} \Z{95}. Ohne die Neuinitialisierung würde die Eingabemaske immer die zuletzt eingetragene Maßnahme enthalten. Dies würde große Verwirrung beim Benutzer stiften.

The \IC{FloatingActionButton} erhält den Schlüssel \IC{createNewMassnahmeButtonKey} \Z{89}.
Er ist als \IC{GlobalKey} deklariert \Z{11}.
Er findet beim Integrationstest Anwendung, um den Button zu finden ( Siehe Kapitel \HP{Kapitel einfügen}).

Der Inhaltsbereich des \IC{Scaffold} beinhaltet das Widget \IC{StreamBuilder} \Z{27}.
Er kann auf \enquote{Streams} horchen, die Ereignisse des Typs \IC{Storage} übermitteln.
Er horcht auf Änderungen im \enquote{Model}, um genau zu sein auf Änderungen des \enquote{Streams} \IC{model.storage} \Z{28}. Sobald der \IC{StreamBuilder} ein Ereignis erhält, so führt er die Methode aus, die als Argument des Parameters \IC{builder} hinterlegt ist. Alle Widgets außerhalb davon, wie etwa das \IC{Scaffold}, erhalten dabei keine Aufforderung zum Neuzeichnen, sobald eine Maßnahme hinzugefügt wird. Das wirkt sich positiv auf die Laufzeit-Geschwindigkeit aus.


\ifIncludeFigures
  \begin{listing}[htbp]
    \renewcommand\theFancyVerbLine{%
      \ifnum\value{FancyVerbLine}=31
      \setcounter{FancyVerbLine}{85}
      \tiny\ldots
      \else
      \tiny\arabic{FancyVerbLine}%
      \fi
    }
    \begin{minted}[firstnumber=11]{dart}
final createNewMassnahmeButtonKey = GlobalKey();

class MassnahmenMasterScreen extends StatelessWidget {
  static const routeName = '/massnahmen_master';

  const MassnahmenMasterScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final model = AppState.of(context).model;
    final vm = AppState.of(context).viewModel;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Maßnahmen Master'),
      ),
      body: StreamBuilder<Storage>(
          stream: model.storage,
          builder: (context, _) {
            return SingleChildScrollView(
              // ...
            );
          }),
      floatingActionButton: FloatingActionButton(
          key: createNewMassnahmeButtonKey,
          child: const Icon(
            Icons.post_add_outlined,
            color: Colors.white,
          ),
          onPressed: () {
            vm.model = Massnahme();
            Navigator.of(context).pushNamed(MassnahmenDetailScreen.routeName);
          }),
    );
  }
}
\end{minted}
    \alexlistingcaption{Schritt 1}{Die Struktur der Klasse MassnahmenMasterScreen} {Quellcode/Schritt-1/conditional_form/lib/screens/massnahmen_master.dart}
    \label{lst:Schritt1KlasseMassnahmenMasterScreenStruktur}
  \end{listing}
\fi

\ifIncludeFigures \clearpage \fi
\subsection{Auflistung der Maßnahmen im Übersichtsbildschirm}

Der Inhalt der \IC{builder}-Methode ist in Listing \ref{lst:Schritt1DieAusgabeDerMassnahmen} dargestellt.
Das erste Widget ist ein \IC{SingleChildScrollView} \Z{30}.
Das Argument \IC{scrollDirection} ist nicht gefüllt, weshalb die Standardoption -- die vertikale Scrollrichtung -- gewählt wird.
Sollte die Liste der Maßnahmen die Höhe des Fensters überschreiten, so kann der Benutzer vertikal über die Liste scrollen.

\begin{alexlisting}{Schritt 1}{Die Ausgabe der Maßnahmen}
  {Quellcode/Schritt-1/conditional_form/lib/screens/massnahmen_master.dart}
  {firstline=30, lastline=86}
  \label{lst:Schritt1DieAusgabeDerMassnahmen}
\end{alexlisting}

Das Kind des Scrollbereichs ist ein \IC{Column}-Widget \Z{31}.
Es zeichnet Widgets, die als Argument des Parameters \IC{children} gesetzt sind, von oben nach unten.
Der Parameter \IC{crossAxisAlignment} gibt an, wie die Kindelemente ausgerichtet sein sollen. \IC{crossAxis} bedeutet dabei die entgegengesetzte Achse zur Anzeige-Richtung. Da die \IC{Column} vertikal zeichnet, ist mit \IC{crossAxis} die horizontale Achse gemeint. \IC{CrossAxisAlignment.start} beschreibt, dass Elemente entlang der horizontalen Achse an dessen Startpunkt auszurichten sind. Dadurch sind alle Elemente der Liste linksbündig.

Zuerst kommt die Auflistung der abgeschlossenen Maßnahmen.
Die Überschrift \IC{"Abgeschlossen"} \Z{37} soll einen Abstand von jeweils 16 Pixel in alle Richtungen haben.
Das ermöglicht das Widget \IC{Padding} \Z{35-40} und das Argument \IC{EdgeInsets.all(16.0)}. Nach der Überschrift erscheint als zweites Element in der \IC{Column} ein weiterer \IC{SingleChildScrollView} \Z{41-57}, allerdings dieses Mal mit horizontaler Scroll-Richtung \Z{42}. Sollten die Informationen der Maßnahmen die Breite des Fensters überschreiten, kann der Nutzer von links nach rechts scrollen.

Die Informationen der Maßnahmen werden in einer Tabelle angezeigt.
Dies übernimmt das selbstgeschriebene \enquote{Widget} \IC{MassnahmenTable} \Z{45}.
Als erstes Argument erfolgt die Übergabe der anzuzeigenden Maßnahmen aus dem \enquote{Model}. \IC{storage.value.massnahmen} gibt den aktuellen Wert des \enquote{Streams} des \IC{storage}-Objekts zurück und greift auf die Liste der Maßnahmen zu. Mit der Methode \IC{where} \Z{47} kann ein Filter auf die Liste angewendet werden. Die übergebene anonyme Funktion \Z{47-49} überprüft, ob der letzte Status auf \enquote{fertig} gesetz ist. Dazu reicht der Vergleich der Abkürzung. Nur wenn diese Bedingung erfüllt ist, bleibt die Maßnahme in der gefilterten Kollektion zurück. Ein solcher Filter gibt ein sogenanntes \enquote{lazy} \IC{Iterable} zurück. Erst beim Zugriff auf das Ergebnis findet der Filter Anwendung. Doch es gibt keinen Zwischenspeicher für die gefilterten Elemente. Jeder Zugriff filtert die Elemente also neu. Der Aufruf \IC{toSet} bewirkt allerdings das Speichern der Ergebnisse in einer Menge \Z{50}. Das Widget \IC{MassnahmenTable} erhält das Resultat um es in einer Tabelle anzuzeigen.

Ein weiterer Parameter ist \IC{onSelect} \Z{50}.
Als Argument kann eine Funktion mit genau einem Parameter gesetzt werden.
Sollte der Benutzer in der Tabelle eine Maßnahme auswählen, so löst er damit die Funktion aus.
Der erste Parameter enthält dann die ausgewählte Maßnahme.
Daraufhin soll sich wieder die Eingabemaske öffnen \Z{55-56}.
Dann beinhalten die Eingabefehler jedoch die Werte der ausgewählten Maßnahme.  Um das zu erreichen, reicht eine Zuweisung der Maßnahme an das \enquote{ViewModel} \Z{51}. Allerdings soll die Maßnahme zuvor ein neues letztes Bearbeitungsdatum mit dem aktuellen Zeitstempel erhalten \Z{51-53}.

Unterhalb der Rubrik der finalen Maßnahmen listet die Übersicht die Maßnahmen, welche sich noch im Entwurf befinden \Z{59-83}.
Daher ist das dritte Element der \IC{Column} wiederum eine Überschrift: \IC{"In Bearbeitung"} \Z{62} gefolgt von einem weiteren horizontalen Scrollbereich \Z{66-83} mit einer Tabelle von Maßnahmen \Z{70-82}.
Der einzige Unterschied ist hier die Bedingung der Filterfunktion.
Dieses Mal filtert die Kollektion auf Maßnahmen in Bearbeitung \Z{73-74}.


\section{Widget MassnahmenTable}

Die \IC{MassnahmenTable} ist ein  \IC{StatelessWidget} \LstZ{\ref{lst:Schritt1KlasseMassnahmenTable}}{6}.
Zur Anzeige eignet sich das Widget \IC{Table} \Z{15-31}. 



Im Verlauf der Erstellung der Arbeit wurde versucht das Widget \IC{DataTable} zu verwenden.
Doch im Gegensatz zur \IC{DataTable} erlaubt es die Table, unterschiedlich hohe Zeilen zu zeichnen.
Die Höhe der Zeile wird dazu in Abhängigkeit von dem benötigten Inhalt der Zellen berechnet.
Die Breite und Ausrichtung der Spalten kann konfiguriert werden.
Die Eigenschaft \IC{IntrinsicColumnWidth} sorgt dafür, dass die Spalten immer genau so groß sind, wie der Inhalt es benötigt \Z{17}.  Zeilenumbrüche für die Texte in den Spalten sind somit nicht notwendig. \IC{TableCellVerticalAlignment.middle }lässt die  Tabelle die Inhalte zentriert darstellen \Z{18}.

Der Parameter \IC{children} erhält als Argument eine Liste von \IC{TableRow} Elementen \Z{20-30}.
Die erste Tabellenzeile \IC{20-23} beinhaltet die Spalten-Bezeichnungen.
Jede \IC{TableRow} hat wiederum den Parameter \IC{children}.
Das Argument bezieht sich hier auf die Zellen in der Zeile.
Dabei ist wichtig, dass jede \IC{TableRow} die gleiche Anzahl von Zellen hat.
Weicht nur eine Zeile davon ab, zeichnet sich die gesamte Tabelle nicht und eine Ausnahme wird ausgelöst.
Für die Spaltenbezeichnungen wurde eine Hilfsmethode kreiert: \IC{_buildColumnHeader} \Z{34-37}.
Sie zeichnet die Spalten mit einem Abstand von 8 Pixeln in alle Richtungen.

Nach den Spaltenbezeichnungen folgen die Zeilen für die Daten der Maßnahmen \Z{24-29}.
Die Methode \IC{map} \Z{24} ermöglicht es dazu durch die Liste der Maßnahmen zu iterieren und für jede Maßnahme ein Element eines völlig anderen Typs -- in diesem Fall \IC{TableRow} -- zurückzugeben.
Bei den vorangestellten Punkten \IC{...} in Zeile 24 handelt sich um den spread operator. Die Filtermethode \IC{map} und die darauffolgende Methode \IC{toList} liefern eine Liste von \IC{TableRow} Elementen. Die umgebende Liste der Zeilen \IC{children} \Z{19-30} erwartet jedoch Elemente des Typs \IC{TableRow} und keine Elemente des Typs \IC{List}. Der \enquote{spread operator} ermöglicht, alle Elemente der inneren Liste in die äußere Liste einzufügen. \footcite[Vgl.][]{SpreadOperator}

Eine weitere Hilfsmethode \IC{_buildSelectableCell} erstellt Zellen, die anklickbar sind \Z{39-51}.
Das Widget \IC{TableRowInkWell} \Z{41-51} kann in Tabellen verwendet werden, um einen anklickbaren Bereich zu erstellen.
Beim  Anklicken breitet sich ausgehend von der Position des Klicks ein Tintenklecks  aus.
Dabei überschreitet der Tintenklecks nicht den Bereich, der von der umgebenden Zeile begrenzt ist.
Beim Auslösen des Ereignisses \IC{onTap} erfolgt die Ausführung des Callbacks \IC{onSelect} \Z{44} mit der ausgewählten Maßnahme.
Doch zuvor muss überprüft werden, ob der Callback auch initialisiert wurde \Z{43}.
Wie hier zu sehen ist, reicht es nicht aus, abzufragen, ob \IC{onSelect}  gesetzt ist.
Trotzdem erfolgt keine Typ-Beförderung zu einem Typen ohne Null-Zulässigkeit, denn es handelt sich um eine Instanzvariable.
Deshalb muss der Suffix \IC{!} gesetz sein (Siehe Grundlagenkapitel \ref{sec:TypenMitNullZulaessigkeit} \nameref{sec:TypenMitNullZulaessigkeit}).

Bei \IC{onSelect} handelt es sich um einen Callback.
An diesem Beispiel kann das Inversion of Control Entwurfsmuster visualisiert werden.
Abbildung \ref{lst:UmlOnSelet} zeigt wie die Akteure zusammenarbeiten.
Der \IC{MassnahmenMasterScreen} verwendet die \IC{MassnahmenTable}.
Die Tabelle enthält ein Objekt namens \IC{onSelect}.
Dabei handelt es sich um einen Funktions-Objekt.
Anstatt eine neue Klasse mit einer beinhaltenden Funktion zu deklarieren, kann das gleiche über eine Abkürzung erreicht werden: dem Schlüsselwort \IC{typedef} \Z{4}.
Hier erlaubt es eine Funktionssignatur als einen Typ zu deklarieren.
Der \IC{MassnahmenMasterScreen} wiederum instanziiert ein anonymes Funktions-Objekt, welches der Schnittstelle und damit der Funktionssignatur entspricht \LstZ{\ref{lst:Schritt1DieAusgabeDerMassnahmen}}{75-82}.
Weil es der Signatur der Typdefinition von \IC{OnSelectCallback}  entspricht, kann es der Tabelle als Argument für den Parameter \IC{onSelect} übergeben werden. 

\ifIncludeFigures \clearpage \fi

\begin{alexlisting}{Schritt 1}{Die Klasse MassnahmenTable}
  {Quellcode/Schritt-1/conditional_form/lib/widgets/massnahmen_table.dart}
  {firstline=4}
  \label{lst:Schritt1KlasseMassnahmenTable}
\end{alexlisting}

\ifIncludeFigures \clearpage \fi


Das Inversion of Control Entwurfsmuster ist auch unter dem Namen \enquote{hollywood pattern} bekannt, da es ähnlich wie die typische Antwort auf eine Bewerbung für einen Hollywood Film -- don’t call us, we’ll call you -- funktioniert.\footcite[Vgl.][]{fowler2005InversionOfControl}

Und genauso arbeiten der Übersichts-Bildschirm und die Tabelle zusammen.
Der Übersichtsbildschirm verwendet die Tabelle, welche nicht wissen muss, wofür sie eingesetzt wird.
Sobald die Tabelle eine Selektion des Benutzers bemerkt, kommuniziert sie wieder mit dem Übersichtsbildschirm, worauf dieser über den \enquote{Service Locator} auf das \enquote{ViewModel} zugreift, um die selektierte Maßnahme zu übergeben.

\ifIncludeFigures
  \begin{figure}[h]
    \centering

    \begin{tikzpicture}
      \begin{umlseqdiag}
    
        \umlclass[x=0, y=-2.7]{MassnahmenMasterScreen}{
        }{
        }
    
        \umlclass[x=8,y=-2.7]{MassnahmenTable}{
        }{
        }
    
        \umlclass[x=8.0,y=0,type=typedef]{OnSelectCallback}{
        }{
        }
    
    
        \umlobject[x=0,y=0, class=OnSelectCallback]{onSelect}{
        }{
        }
    
    
    
    
        \umldep[arg=<<instance of>>, pos=0.5]{onSelect}{OnSelectCallback}
        \umldep[arg=<<instantiate>>, pos=0.5]{MassnahmenMasterScreen}{onSelect}
    
    
        \umluniassoc[]{MassnahmenMasterScreen}{MassnahmenTable}
        \umluniaggreg[arg=onSelect, pos=0.5]{MassnahmenTable}{OnSelectCallback}
      \end{umlseqdiag}
    \end{tikzpicture}

    \caption[UML Diagramm]{UML Diagramm, Quelle: Eigene Abbildung}
    \label{lst:UmlOnSelet}

  \end{figure}%
\fi







\section{Das \enquote{ViewModel}}

Listing \ref{lst:Schritt1KlasseMassnahmenFormViewModel} zeigt das \enquote{ViewModel}.
Im ersten Schritt enthält es nur drei \enquote{Streams} vom Typ \IC{BehaviorSubject}.
Eines für den letzten Status \Z{6}, eines für die \enquote{guid} \Z{8} und eines für den Titel der Maßnahme \Z{10}.
Anhand dessen wird offensichtlich, warum ein \enquote{ViewModel} nötig ist.
Die Daten, die in der Oberfläche angezeigt werden, sind \enquote{Streams}, die neue Werte annehmen können.
Wann immer sich ein Wert ändert, löst der \enquote{Stream} ein neues Ereignis aus.
Auf dieses Ereignis kann der \enquote{View} reagieren.
Das \enquote{Model} bietet die Eigenschaften der Maßnahmen dagegen nicht als \enquote{Stream} an.

Weil sich \enquote{Model} und \enquote{ViewModel} in ihrer Struktur unterscheiden, gibt es zwei Methoden, die die Konvertierung in beide Richtungen vornehmen.
Die Setter-Methode \IC{model} \Z{12-18} erhält ein Objekt des Wertetyps \IC{Massnahme}.
Die einzelnen Eigenschaften werden dann in das Format des \enquote{ViewModels} umgewandelt: in \enquote{Streams}.
Darüber wird der Setter-Methode \IC{value} von jedem \IC{BehaviorSubject} der entsprechende Wert aus dem \enquote{Model} zugewiesen.
Besonders ist auch, wie die Auswahloptionen sich im \enquote{Model} und \enquote{ViewModel} unterscheiden. Im \enquote{ViewModel} sind es abgeleitete Objekte der Basisklasse Choice, wie z.b. LetzterStatus.  Im Gegensatz dazu speichert das \enquote{Model} die Optionen lediglich über die Abkürzung als String ab. Mithilfe der Methode \IC{fromAbbreviation} kann anhand der Abkürzung das entsprechende Objekt wiedergefunden werden \Z{16}.

Die Getter-Methode dagegen konvertiert in das exakte Gegenteil.
Die aktuellen Werte von jedem \IC{BehaviorSubject} werden über die Getter-Methode \IC{value} ausgelesen und anschließend der entsprechenden Eigenschaft des Objekts vom Wertetyp \IC{Massnahme} gespeichert.
Die Auswahloption, die für den letzten Status hinterlegt wurde, wird dabei wiederum nur als Abkürzung eingetragen.
Dementsprechend ist bloß die Eigenschaft \IC{abbreviation} abzufragen \Z{22}.

Allerdings kann bei Auswahlfeldern auch keine Option gewählt sein.
Die Getter-Methode \IC{value} kann daher also auch \IC{null} zurück geben.
Der Compiler gibt einen Fehler aus, wenn versucht wird, auf \IC{value} eine Operation auszuführen, sollte es sich um einen Typ mit Null-Zulässigkeit handeln.
So ist es bei dem Aufruf von \IC{abbreviation} der Fall \Z{22}.
Der Fehler kann nur damit behoben werden, indem das Prefix \IC{?}  der Operation vorangestellt wird.
In diesem Fall wird die Methode aufgerufen, sollte \IC{value} nicht \IC{null} sein.
Ist \IC{value} dagegen \IC{null}, so wird die Operation nicht ausgeführt und der gesamte Ausdruck gibt direkt \IC{null} zurück.

\begin{alexlisting}{Schritt 1}{Die Klasse MassnahmenFormViewModel}
  {Quellcode/Schritt-1/conditional_form/lib/screens/massnahmen_detail/massnahmen_form_view_model.dart}
  {firstline=5}
  \label{lst:Schritt1KlasseMassnahmenFormViewModel}
\end{alexlisting}

