\chapter{Grundlagen}
\label{chap:Grundlagen}

Für die Formularanwendung wurde die Programmiersprache \enquote{Dart} und das Frontend-Framework \enquote{Flutter} gewählt.
Kapitel \ref{chap:Technologie-Auswahl} erläutert die Entscheidungsgrundlage dafür.
Nachfolgend soll auf die Grundlagen der beiden Technologien eingegangen werden.

\section{Flutter}
\label{sec:Flutter-Grundlagen}

\enquote{Flutter} ist ein Framework von Google zur Entwicklung von Oberflächen.
Es unterstützt eine breite Anzahl an Zielsystemen.
 Dazu gehören:

\begin{itemize}[topsep=0pt,itemsep=-1ex,partopsep=1ex,parsep=1ex]
  \item Desktop:\footcite[Vgl.][]{DesktopSupportForFlutter}
        \begin{itemize}
          \item \enquote{Windows}:
                \begin{itemize}
                  \item \enquote{Win32},
                  \item \enquote{Universal Windows Platform},
                \end{itemize}
          \item \enquote{macOS},
          \item \enquote{Linux},
        \end{itemize}
  \item Mobile Endgeräte\footcite[Vgl.][]{FlutterBeautifulNativeAppsInRecordTime}:
        \begin{itemize}
          \item \enquote{Android},
          \item \enquote{iOS},
        \end{itemize}
  \item und das Web\footcite[Vgl.][]{WebSupportForFlutter}.
\end{itemize}

\enquote{Flutter} ist inspiriert durch das Webframework \enquote{React} und deren Oberflächenelemente, die \enquote{Components} genannt werden \footcite[Vgl.][]{IntroductionToWidgets}.
Die visuellen Oberflächenelemente in \enquote{Flutter} werden dagegen \enquote{Widgets} \pdfcomment[icon=Note,color=yellow]{27.08.2021 4. Einschub im nächsten Satz}genannt.
Bei \enquote{Flutter} und \enquote{React} handelt es sich um deklarative Frontend-Frameworks.
Dem stehen die imperativen Frameworks gegenüber.

\clearpage
In imperativen Frameworks werden Befehle genutzt, um Änderungen direkt an der Oberfläche vorzunehmen,
wie am \enquote{Java Swing}-Beispiel in Listing \ref{lst:HelloWorldJavaSpring} zu sehen ist.
Es wird ein Button erstellt, welcher die Anzahl der auf ihn angewendeten Klicks anzeigt.
Bei jedem Klick wird die \enquote{Setter}-Methode \IC{setText} genutzt, um den Text direkt zu manipulieren.

\ifIncludeFigures
  \begin{listing}[h]
    \begin{minted}[]{java}
final JButton button = new JButton("Anzahl der Klicks auf diesen Button: 0");

button.addActionListener(new ActionListener() {
   @Override
   public void actionPerformed(ActionEvent e) {
      timesClicked = timesClicked + 1;
      button.setText("Anzahl der Klicks auf diesen Button: " + timesClicked);
   }
});
\end{minted}
    \caption[\enquote{Java Swing}-Beispiel: Ein Button, welcher die Anzahl der Klicks anzeigt]{\enquote{Java Swing}-Beispiel: Ein Button, welcher die Anzahl der Klicks anzeigt, Quelle: Eigenes Listing}
    \label{lst:HelloWorldJavaSpring}
  \end{listing}
\fi

In deklarativen Frontend-Frameworks wie \enquote{Flutter} existieren solche \enquote{Setter}-Methoden nicht.
Stattdessen wird die Oberfläche einmal deklariert und darauf vorbereitet, auf Änderungen eines Zustands zu reagieren.
Das \enquote{Flutter}-Beispiel in Listing \ref{lst:ClickExampleFlutter} zeigt dieses Verhalten.
Beim Klick auf den Button modifiziert die Methode \IC{setState} den Zustand und löst damit die Aktualisierung der Oberfläche aus.

\ifIncludeFigures
  \begin{listing}[h]
    \begin{minted}[]{java}
return ElevatedButton(
  onPressed: () {
    setState(() {
      timesClicked = timesClicked + 1;
    });
  },
  child: Text("Anzahl der Klicks auf diesen Button: $timesClicked")
)
\end{minted}
    \caption[\enquote{Flutter}-Beispiel: Ein Button, welcher die Anzahl der Klicks anzeigt]{\enquote{Flutter}-Beispiel: Ein Button, welcher die Anzahl der Klicks anzeigt, Quelle: Eigenes Listing}
    \label{lst:ClickExampleFlutter}
  \end{listing}
\fi

\pdfcomment[icon=Note,color=yellow]{27.08.2021 4. Einschub bis hier}
In \enquote{react} \enquote{Components} wird dieser Zustand \enquote{State} genannt.
\enquote{Flutter} unterscheidet allerdings zwischen zwei Arten von \enquote{Widgets}: denen, die einen Zustand pflegen -- den \enquote{Stateful Widgets} -- und solchen, die keinen Zustand haben -- den \enquote{Stateless Widgets}.

\subsection{\enquote{Stateful Widgets}}

\enquote{Stateful Widgets} pflegen einen Zustand, der mittels der Methode \IC{setState} gesetzt werden kann.
Beim Aufrufen der Methode wird das gesamte \enquote{Widget} neu gezeichnet.
Der Zustand selbst ist dabei im visuellen Baum als Vater der visuellen Elemente des \enquote{Widgets} verankert und bleibt erhalten, während die dazugehörigen Oberflächenelemente ausgetauscht werden.

\subsection{\enquote{Stateless Widgets}}


\enquote{Stateless Widgets} haben dagegen keinen solchen Mechanismus. \pdfcomment[icon=Note,color=yellow]{27.08.2021 3. Einschub von hier}
Wie alle \enquote{Widgets} werden sie neu gezeichnet, wenn es durch das Framework angeordnet wurde.
Das ist der Fall,
\begin{itemize}[topsep=0pt,itemsep=-1ex,partopsep=1ex,parsep=1ex]
  \item wenn das \enquote{Widget} zum ersten Mal in der Oberfläche auftaucht,
  \item das Vaterelement und damit alle Kinderelemente neu gezeichnet werden
  \item oder wenn das \enquote{Widget} von einem \enquote{InheritedWidget} abhängig ist und dieses aktualisiert wird.\footcite[Vgl.][]{StatelessWidget}
\end{itemize}\pdfcomment[icon=Note,color=yellow]{27.08.2021 3. Einschub bis hier}


\enquote{StatefulWidgets} sind nur eine von vielen Möglichkeiten den Zustand des Programms zu verwalten.
Die Formularanwendung verwendet ausschließlich \enquote{StatelessWidgets}, da die Verwaltung des Zustands über das sogenannte \enquote{Model-View-ViewModel}-Entwurfsmuster umgesetzt wird.
Mehr dazu im Kapitel \ref{sec:ModelViewViewModel} \enquote{\nameref{sec:ModelViewViewModel}} auf Seite \pageref{sec:ModelViewViewModel}.

\subsection{\enquote{Inherited Widgets}\pdfcomment[icon=Note,color=yellow]{27.08.2021 4. Einschub von hier}}

Neben den zwei Basisklassen \enquote{StatelessWidget} und \enquote{StatefulWidget} sei noch das \enquote{InheritedWidget} zu nennen.
Es wird in der Regel nicht für eine visuelle Repräsentation genutzt. Stattdessen zeichnet es das ihm übergebene Kindelement unverändert.
Die Hauptaufgabe eines \enquote{InheritedWidget} ist es dagegen, dem \enquote{Widget}-Baum Informationen bzw. Services verfügbar zu machen.\footcite[Vgl.][]{InheritedWidget}
Mehr dazu im Kapitel \ref{sec:ServiceFuerDenApplikationsuebergreifendenZustand}. 
\pdfcomment[icon=Note,color=yellow]{27.08.2021 4. Einschub bis hier}

\section{\enquote{Dart} Grundlagen}
\label{sec:Dart-Grundlagen}

\enquote{Flutter}-Anwendungen werden in der Programmiersprache \enquote{Dart} geschrieben.
Nachfolgend soll auf eine Reihe von Besonderheiten von \enquote{Dart} im Vergleich zu anderen objektorientierten Programmiersprachen eingegangen werden.

\enquote{Dart} ist eine Hochsprache, die hauptsächlich für die Entwicklung von Oberflächen entwickelt wurde, sich jedoch ebenso dazu eignet, Programme für das Back-End zu entwickeln.

Ein Hauptaspekt bei dem Design der Sprache ist die Produktivität des Entwicklers.
Mechanismen wie das \enquote{hot reload} verkürzen die Entwicklungszyklen erheblich.
Das \enquote{hot reload} ermöglicht es, während eine Anwendung im Debugmodus ausgeführt wird, Änderungen an deren Quellcode vorzunehmen.
Daraufhin werden nur die Teile der laufenden Applikation aktualisiert, die tatsächlich verändert wurden.\footcite[Vgl.][]{HotReload}
 Währenddessen bleibt die Anwendung in der gleichen Ansicht, anstatt zum Hauptbildschirm zurückgesetzt zu werden, von der aus der Entwickler erneut zur gewünschten Ansicht zurücknavigieren müsste.

\subsection{\enquote{AOT} und \enquote{JIT}}
Nicht nur für die reibungslose Entwicklung, sondern auch für das Laufzeitverhalten der finalen Applikation wurde die Sprache optimiert.
Für die Zielarchitekturen \enquote{ARM32}, \enquote{ARM64} und \enquote{x86_64} wird \enquote{Dart} in Maschinencode kompiliert \footcite[Vgl.][]{DartThePlatforms}.

Dementsprechend kommt während der Entwicklung eine virtuelle Maschine -- die \enquote{Dart VM} -- über \enquote{Just-in-time}-Kompilierung (JIT) zum Einsatz.
Für die Kompilierung in Maschinencode wird dagegen \enquote{Ahead-of-time}-Kompilierung (\enquote{AOT}) eingesetzt.

\subsubsection{tree shaking}
Für die Minimierung der Dateigröße des resultierenden Kompilats wird das sogenannte \enquote{tree shaking} eingesetzt.
Das Hauptprogramm importiert über das Schlüsselwort \enquote{import} Funktionalitäten aus  weiteren \enquote{Dart}-Dateien oder sogar ganzen Bibliotheken.
Diese Dateien importieren wieder weitere.
Dadurch wird ein Baum aufgespannt.
Das \enquote{tree shaking} identifiziert, welche Funktionalitäten tatsächlich vom Programm verwendet werden und welche nicht.
Dies bringt aber eine wichtige Einschränkung mit sich.
Die Metaprogrammierung (der Zugriff auf sprachinterne Eigenschaften, wie etwa Klassen und ihre Attribute) ist damit stark eingeschränkt.

\subsubsection{Metaprogrammierung}
Bei der Kompilierung werden die Original-Bezeichner durch Symbole ersetzt, welche minimalen Speicherbedarf haben.
Aber nicht nur das, denn durch das \enquote{tree shaking} werden auch etwaige Eigenschaften und Funktionalitäten entfernt, die nicht verwendet werden.
Die sogenannte \enquote{Reflexion} oder \enquote{Introspektion} versucht auf solche Metainformationen während der Laufzeit zuzugreifen.
Da die Eigenschaften aber nicht mehr verfügbar sind, ist \enquote{Reflexion} nicht anwendbar.
\enquote{Dart} greift daher auf eine andere Variante der Metaprogrammierung zurück: die Codegenerierung.

\subsubsection{Codegenerierung}
Das Package \enquote{source_gen} erlaubt das Auslesen der Metainformationen und ermöglicht das Generieren von Quellcode, der von diesen Eigenschaften abgeleitet werden kann.\footcite[Vgl.][]{SourceGen}
So verwendet beispielsweise das Package \enquote{built_value} die Codegenerierung.\footcite[Vgl.][]{BuiltValueGenerator}
Zunächst werden Eigenschaften wie Klassennamen und Instanzvariablen mit ihren Bezeichnern und Datentypen gelesen.
Die Eigenschaften können dann genutzt werden, um unveränderliche Wertetypen und dazugehörige sogenannte \enquote{Builder}-Objekte des \enquote{Erbauer}-Entwurfsmusters, sowie Funktionen zum Serialisieren und Deserialisieren von Objekten zu generieren.

\subsection{\enquote{Set}- und \enquote{Map}-Literale}
\label{sec:SetUndMapLiterale}

\enquote{Dart} erlaubt es Listen (\enquote{List}), Mengen (\enquote{Set}) und Hashtabellen (\enquote{Map}) als sogenannte Literale zu deklarieren.
Ein Literal ist die textuelle Repräsentation eines Wertes eines speziellen Datentyps.
Beispielsweise ist \IC{"Text"}  ein \enquote{String}-Literal für eine Zeichenkette mit den Elementen \enquote{T}, \enquote{e}, \enquote{x}, \enquote{t}.
So ist auch \IC{{"Text"}}  ein Literal für eine Menge (\enquote{Set}).
Eine Menge mit den gleichen Werten könnte genauso auch wie in Listing \ref{lst:EinSet} erstellt werden.

\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
var menge = Set();
menge.add("Text");
\end{minted}
    \caption[Ein \enquote{Set}]{Ein \enquote{Set}, Quelle: Eigenes Listing}
    \label{lst:EinSet}
  \end{listing}
\fi

Es entfällt also die Instanziierung einer Liste, einer Menge oder einer Hashtabelle über den Klassennamen und der darauffolgenden Zuweisung der einzelnen Werte.
Stattdessen startet das \enquote{Set}- und \enquote{Map}-Literal mit einer öffnenden geschweiften Klammer und endet mit einer schließenden geschweiften Klammer.
Innerhalb der Klammern werden die Werte im Fall eines \enquote{Sets} mit \IC{,} getrennt nacheinander aufgeführt ( \IC{{1,2}} ).
Im Fall einer \enquote{Map} werden der Schlüssel und der Wert durch einen \IC{:} voneinander getrennt und die Schlüssel-Wertepaare wiederum durch \IC{,} getrennt nacheinander aufgelistet (\IC{{1: "Wert 1", 2:"Wert 2"}}).
Eine Liste wiederum wird mit eckigen Klammern geöffnet und geschlossen.
Die Werte werden erneut mit \IC{,} getrennt voneinander angegeben (\IC{[1,2]}).

\subsubsection{\enquote{Collection for}} \enquote{Dart} erlaubt es Schleifen innerhalb von Listen-, Mengen- und Hashtabellen-Literalen zu verwenden.
Dabei darf die Schleife jedoch keinen Schleifen-Körper besitzen.
Lediglich der Schleifen-Kopf wird dazu im Literal geschrieben.
Darauf folgt der Wert, der bei jedem Schleifendurchlauf hinzugefügt werden soll.
Dabei kann der Wert von der Schleifenvariable genutzt oder davon abgeleitet werden.
Listing \ref{lst:CollectionForInEinerMenge} geht beispielsweise durch die Liste der Temperaturangaben 97.7,105.8, die in Fahrenheit gelistet sind.

\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
var gradCelsiusTemperaturen = {
    for (var f in [97.7, 101.3, 105.8])
        (f - 32) * 5 / 9
};
\end{minted}
    \caption[Das \enquote{collection for} in einer Menge]{Das \enquote{collection for} in einer Menge, Quelle: Eigenes Listing}
    \label{lst:CollectionForInEinerMenge}
  \end{listing}
\fi

Für jeden Schleifendurchlauf wird die Schleifenvariable \IC{f} mit der entsprechenden Formel in Grad Celsius umgewandelt.
Das Ergebnis ist somit äquivalent mit dem \enquote{Set}-Literal \IC{{36.5, 38.5, 41}}.



Gleiches gilt für Hashtabellen.
Hierbei wird ein Schlüssel-Werte-Paar übergeben.
Links von einem \IC{:} ist der Schlüssel und rechts davon der Wert.
In Listing \ref{lst:CollectionForInEinerHashtabelle}
wird durch  die gleiche Liste von Temperaturen in Fahrenheit iteriert.


\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
var celsiusUndFahrenheit = {
    for (var f in [97.7, 101.3, 105.8])
        (f - 32) * 5 / 9 :  f
};
\end{minted}
    \caption[Das \enquote{collection for} in einer Hashtabelle]{Das \enquote{collection for} in einer Hashtabelle, Quelle: Eigenes Listing}
    \label{lst:CollectionForInEinerHashtabelle}
  \end{listing}
\fi

Für jede Schleifenvariable \IC{f} wird für das resultierende Schlüssel-Werte-Paar das Ergebnis in Grad Celsius als Schlüssel und die ursprüngliche Temperatur in Fahrenheit als Wert eingetragen. \pdfcomment[icon=Note,color=yellow]{27.08.2021 Fehler behoben}
Das Ergebnis von \IC{celsiusUndFahrenheit} ist dementsprechend eine \enquote{Map} mit dem Wert: \IC{{36.5: 97.7, 38.5: 101.3, 41: 105.8}}



\subsubsection{\enquote{Collection if}}

Neben dem \enquote{collection for} ist auch die Nutzung von Fallunterscheidungen in Kollektionen erlaubt.
Vor dem Wert, der in die Kollektion aufgenommen werden soll oder nicht,  kann  das Schlüsselwort \IC{if} mit einer darauffolgenden Bedingung in Klammern gesetzt werden.
Listing \ref{lst:CollectionIfInEinerListe} iteriert durch eine Anzahl von Temperaturen in Grad Celsius.


\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
var fieberTemperaturen = [
    for (var c in [36.5, 38.5, 41])
        if (c >= 38.5) c
];
\end{minted}
    \caption[\enquote{Collection if} in einer Liste]{Das \enquote{collection if} in einer Liste, Quelle: Eigenes Listing}
    \label{lst:CollectionIfInEinerListe}
  \end{listing}
\fi

Nur in dem Fall, dass die Temperatur der Schleifenvariable \IC{c} größer oder gleich \IC{38,5} ist, wird die Temperatur der Liste hinzugefügt.\pdfcomment[icon=Note,color=yellow]{27.08.2021 \enquote{hinzugefügt}}
Das Ergebnis der Liste \IC{fieberTemperaturen} ergibt also \IC{[38.5, 41]}.


\subsection{Typen ohne Null-Zulässigkeit} Im Vergleich zu vielen anderen Programmiersprachen -- wie beispielsweise \enquote{Java} -- wird in \enquote{Dart} zwischen Typen mit und ohne Null-Zulässigkeit unterschieden.\pdfcomment[icon=Note,color=yellow]{27.08.2021 Satz angepasst}
In \enquote{Java} ist es nur bei atomaren Datentypen wie \enquote{int} und \enquote{float} verpflichtend einen Wert anzugeben.
\enquote{null} ist bei diesen primitiven Datentypen nicht als Wert erlaubt.
Doch nicht atomare Datentypen erlauben immer die Angabe von \enquote{null} als Wert.
\enquote{null} drückt dabei immer das Nicht-Vorhandensein von Daten aus.
Ab \enquote{Dart} 2.12   kann allen Datentypen standardmäßig kein Null-Wert zugewiesen werden. \footcite[Vgl.][]{AnnouncingDartTwoDotTwelve}
Das hat den Vorteil, dass der Compiler sich darauf verlassen kann, 
dass eine Variable niemals den Wert \enquote{null} haben kann. 
Das ist besonders dann nützlich, 
wenn auf einem Objekt eine Methode aufgerufen wird. 
Ist das Objekt in Wahrheit \enquote{null}, 
so gibt es erst zur Laufzeit einen Fehler, 
da die Methode auf der Referenz \enquote{null} nicht aufgerufen werden kann. 
Damit ein Laufzeitfehler geworfen werden kann, 
muss vor jedem Aufruf einer Methode auf einer Referenz überprüft werden, ob die Referenzen nicht \enquote{null} sind. 
Würde diese Überprüfung nicht stattfinden, 
so könnte kein Laufzeitfehler geworfen werden und das Programm würde ohne Fehlermeldung abstürzen. 
Handelt es sich allerdings um eine Referenz, 
die niemals den Wert \enquote{null} annehmen kann, 
so kann der Compiler die Überprüfung auf Null-Werte für diese Referenzen überspringen. 
Damit erhört sich zusätzlich die Ausführungsgeschwindigkeit, 
da die Überprüfung Zeit in Anspruch nimmt. 
Vor allem aber ist es vorteilhaft für den Entwickler, 
da der Compiler  Fehlermeldungen und Warnungen mitteilen kann, 
wenn Operationen auf Variablen mit potenziellen Null-Werten verwendet werden. 
Die Abwesenheit von Daten ist jedoch bei der Entwicklung sehr wichtig. 
Nicht alle Variablen können immer einen Wert haben. 
Aus diesem Grund gibt es in \enquote{Dart} auch die Typen, 
die Null-Werte zulassen.
Allerdings gelten besondere Regeln für diese Typen.

\subsection{Typen mit Null-Zulässigkeit}
\label{sec:TypenMitNullZulaessigkeit}

Wird in \enquote{Dart} hinter einem Typ ein \IC{?} angegeben, 
so kann die Variable nicht nur  Werte annehmen, die dieser Datentyp zulässt,
sondern zusätzlich auch noch den Wert \enquote{null}.
Methoden auf Objekten mit Null-Zulässigkeit aufzurufen ist nicht ohne Weiteres möglich.

Im Listing \ref{lst:printTemperatureInCelsius}
wird versucht, auf die Variable \IC{fahrenheitTemperature} den Operator \IC{-} anzuwenden, um sie mit \IC{32} zu subtrahieren.


\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
        void printTemperatureInCelsius(int? fahrenheitTemperature) {
            print((fahrenheitTemperature - 32) * 5 / 9);
        }
\end{minted}
    \caption[Fehlerhafter Zugriff auf eine Variable mit Null-Zulässigkeit]{Fehlerhafter Zugriff auf eine Variable mit Null-Zulässigkeit, Quelle: Eigenes Listing}
    \label{lst:printTemperatureInCelsius}
  \end{listing}
\fi

Der Compiler liefert jedoch einen Fehler, da der Wert der Variablen \enquote{null} sein kann, wie die Notation \IC{int?} anzeigt.
Solange nicht feststeht, dass die Variable zur Laufzeit tatsächlich nicht \enquote{null} ist, kann das Programm nicht kompiliert werden.


Zu diesem Zweck macht \enquote{Dart} von der sogenannten \enquote{type promotion} -- deutsch Typ-Beförderung -- Gebrauch.
Mithilfe einer Fallunterscheidung kann vor dem Anwenden der Operation nachgesehen werden, ob der Wert der Variablen nicht \IC{null} ist.
Innerhalb des Körpers der Fallunterscheidung wird der Typ der Variablen automatisch in einen Typ ohne Null-Zulässigkeit befördert.\footcite[Vgl.][]{TypePromotionOnNullChecks}
Der Code in Listing \ref{lst:printTemperatureInCelsiusWithIf} lässt sich damit wieder kompilieren.

\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
void printTemperatureInCelsius(int? temperature) {
  if (temperature != null) {
    print((temperature - 32) * 5 / 9);
  }
}
\end{minted}
    \caption[Zugriff auf eine Variable mit Null-Zulässigkeit durch \enquote{type promotion}]{Zugriff auf eine Variable mit Null-Zulässigkeit durch \enquote{type promotion}, Quelle: Eigenes Listing}
    \label{lst:printTemperatureInCelsiusWithIf}
  \end{listing}
\fi

Eine Besonderheit stellen dabei allerdings Instanzvariablen dar.
In \enquote{Dart} wird syntaktisch nicht zwischen dem Aufruf einer \enquote{Getter}-Methode oder einer Instanzvariablen unterschieden.
In Listing \ref{lst:PatientWithoutNullCheck}
könnte sich hinter den Aufrufen von \IC{temperature} in den Zeilen 6 und 7 die Instanzvariable verbergen, die in Zeile 2 deklariert ist.

\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
class Patient {
  num? temperature;
  Patient({this.temperature});

  void printTemperatureInCelsius() {
    if (temperature != null) {
      print((temperature - 32) * 5 / 9);
    }
  }
}
    \end{minted}
    \caption[Fehlerhafter Zugriff auf eine Instanzvariable mit Null-Zulässigkeit]{Fehlerhafter Zugriff auf eine Instanzvariable mit Null-Zulässigkeit, Quelle: Eigenes Listing}
    \label{lst:PatientWithoutNullCheck}
  \end{listing}
\fi

Genauso könnte es aber auch sein, dass eine Klasse von \IC{Patient} erbt und das Feld \IC{temperature} mit einer gleichnamigen \enquote{Getter}-Methode überschreibt.
Auch wenn es sehr unwahrscheinlich ist, könnte es trotzdem vorkommen, dass der Aufruf von \IC{temperature} in Zeile 6 einen Wert zurückgibt,
der nicht \enquote{null} ist und der darauffolgende Aufruf in Zeile 7 \enquote{null} liefert.
So provoziert es die Klasse \IC{UnusualPatient} im Listing \ref{lst:UnusualPatient}.
\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
class UnusualPatient extends Patient {
  int counter = 0;

  num? get temperature {
    counter++;
    if (counter.isOdd) {
      return 97.7;
    } else {
      return null;
    }
  }
}
\end{minted}
    \caption[Überschreiben des Instanzattributs mit einer \enquote{Getter}-Methode]{Überschreiben des Instanzattributs mit einer \enquote{Getter}-Methode, Quelle: Eigenes Listing}
    \label{lst:UnusualPatient}
  \end{listing}
\fi

Beim ersten Aufruf von \IC{temperature} wird die Zählvariable \IC{counter} von \enquote{0} auf \enquote{1} erhöht.
Die Abfrage, ob es sich bei dem Wert von \IC{counter} um eine ungerade Zahl handelt, ist erfolgreich \Z{6}, weshalb mit \IC{97,7} ein valider Wert zurückgegeben wird.
Beim zweiten Aufruf erhöht sich \IC{counter} allerdings auf \enquote{2}.
Die gleiche Abfrage schlägt dieses Mal fehl.
Deshalb liefert die \enquote{Getter}-Methode nun \IC{null} \Z{9}.
Ein solches Szenario ist schon sehr unwahrscheinlich, doch die Typ-Überprüfung des Compilers arbeitet mit Beweisen.
Im Fall von Instanzvariablen kann nicht bewiesen werden, dass zur Laufzeit ein solcher Fall ausgeschlossen werden kann.








Sollte sich der Entwickler sicher sein,
dass die Variable nicht \enquote{null} sein kann,
so kann er mit einem nachgestellten \IC{!} erzwingen,
dass die Variable als nicht \enquote{null} angesehen wird \LstZ{\ref{lst:printTemperatureInCelsiusLocalVariableForceNullCheck}}{3}.

\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
  void printTemperatureInCelsius() {
    if (temperature != null) {
      print((temperature! - 32) * 5 / 9);
    }
  }
    \end{minted}
    \caption[Erzwungener Zugriff auf eine Instanzvariable mit Null-Zulässigkeit]{Erzwungener Zugriff auf eine Instanzvariable mit Null-Zulässigkeit, Quelle: Eigenes Listing}
    \label{lst:printTemperatureInCelsiusLocalVariableForceNullCheck}
  \end{listing}
\fi

Sollte es dann dennoch passieren, dass die Variable \enquote{null} ist, so wird eine Fehlermeldung beim Aufruf der Variablen geworfen.



Eine noch sicherere Variante ist es, die Instanzvariable zuvor in eine lokale Variable zu speichern \LstZ{\ref{lst:printTemperatureInCelsiusLocalVariable}}{2}.


\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
  void printTemperatureInCelsius() {
    num? temperature = this.temperature;
    if (temperature != null) {
      print((temperature - 32) * 5 / 9);
    }
  }
    \end{minted}
    \caption[Zuweisung der Instanzvariablen zu einer lokalen Variablen]{Zuweisung der Instanzvariablen zu einer lokalen Variablen, Quelle: Eigenes Listing}
    \label{lst:printTemperatureInCelsiusLocalVariable}
  \end{listing}
\fi

Die lokale Variable hat keine Möglichkeit zwischen den zwei Aufrufen einen unterschiedlichen Wert anzunehmen.
Somit kann auch das Suffix \IC{!} weggelassen werden \Z{4}.



\subsection{Asynchrone Programmierung}

Wird auf eine externe Ressource zugegriffen -- wie zum Beispiel das Abrufen einer Information von einem Webserver, oder das Lesen einer Datei im lokalen Dateisystem -- so handelt es sich um asynchrone Operationen.

Im Sprachkern stellt \enquote{Dart} Schlüsselwörter und Datentypen für die asynchrone Programmierung bereit.
Das sind unter anderem die Datentypen \enquote{Future} und \enquote{Stream} sowie die Schlüsselwörter \enquote{async} und \enquote{await}.

\subsubsection{Future}
Ein \enquote{Future}-Objekt repräsentiert einen potenziellen einmaligen Wert, der erst in der Zukunft bereit steht.
Er gleicht damit dem sogenannten \enquote{Promise} -- deutsch Versprechen -- in \enquote{JavaScript}  \footcite[Vgl.][]{PromiseJavaScriptMDN}.

Das Listing \ref{lst:fileReadAsString} zeigt mit dem Lesen einer Datei ein Beispiel für den Aufruf einer asynchronen Operation.

\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
var fileContent = file.readAsString();
\end{minted}
    \caption[Der asynchrone Aufruf \enquote{readAsString}]{Der asynchrone Aufruf \enquote{readAsString}, Quelle: Eigenes Listing}
    \label{lst:fileReadAsString}
  \end{listing}
\fi

Anders als erwartet, befindet sich in der Variablen \IC{fileContent} in Wahrheit kein Text mit dem Inhalt der Datei.
Stattdessen hat die Variable den Datentyp \enquote{Future<String>} und ist lediglich ein sogenannter \enquote{Handle}
-- deutsch Referenzwert --
für das potenzielle und zukünftige Ergebnis der Operation.

Mit der Übergabe einer Funktion, die bei Vollendung der Operation aufgerufen wird, kann der Wert ausgewertet werden.
Man nennt diese Operation auch \enquote{Callback}-Funktion -- deutsch Rückruffunktion.
Listing \ref{lst:fileContentThen}
zeigt, wie auf den Dateiinhalt zugegriffen werden kann.

\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
  fileContent.then((text) {
    print("Der Dateiinhalt ist: $text");
  });
\end{minted}
    \caption[Aufruf von \enquote{then} auf dem \enquote{Future}-Objekt]{Aufruf von \enquote{then} auf dem \enquote{Future}-Objekt, Quelle: Eigenes Listing}
    \label{lst:fileContentThen}
  \end{listing}
\fi

Über die Methode \IC{then} wird eine Funktion übergeben, die genau einen Parameter hat.
In diesem Parameter wird der Text der gelesenen Datei bei Vollendung der Operation übergeben.

Der Einsatz von \enquote{Callback}-Funktionen kann den Quellcode stark verkomplizieren.
 Man spricht von der sogenannten \enquote{callback hell} -- deutsch Rückruffunktionen-Hölle --, wenn solche \enquote{Callback}-Funktionen über etliche Level hinweg ineinander verschachtelt sind.

 \clearpage
Um genau das zu verhindern, existieren in \enquote{Dart} die Schlüsselwörter \enquote{async} und \enquote{await}.
Genauso heißen sie auch in anderen Sprachen wie etwa \enquote{C\#} ab Version 4.5 und \enquote{JavaScript} ab Version ES2017
\footcite[Vgl.][]{asyncfunctionJavaScriptMDN}
\footcite[Vgl.][]{Asynchronousprogrammingwithasyncandawait}.





Listing \ref{lst:awaitFileReadAsString} zeigt,
dass das Anwenden des Schlüsselwortes \IC{await} vor der asynchronen Operation \IC{file.readAsString} dafür sorgt,
dass der zukünftige Wert direkt in \IC{fileContent} gespeichert wird.
Ganz ohne \enquote{Callback}-Funktion kann der Dateiinhalt in der darauffolgenden Zeile ausgegeben werden.
Doch jede Funktion, die auf andere Funktionsaufrufe wartet, muss selbst als asynchron gekennzeichnet werden.
Dazu dient das \IC{async} Schlüsselwort vor Beginn des Methoden-Körpers.

\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
printFileContent() async {
  var fileContent = await file.readAsString();
  print("Der Dateiinhalt ist: $fileContent");
}
\end{minted}
    \caption[Aufruf der asynchronen Methode \enquote{readAsString} mit dem \enquote{await}-Schlüsselwort]{Aufruf der asynchronen Methode \enquote{readAsString} mit dem \enquote{await}-Schlüsselwort, Quelle: Eigenes Listing}
    \label{lst:awaitFileReadAsString}
  \end{listing}
\fi



\subsubsection{Streams}

\enquote{Streams} liefern nicht nur einen Wert -- wie im Fall eines \enquote{Future}-Objektes -- sondern eine Serie von Werten, die in der Zukunft geliefert werden.
Listing \ref{lst:countStream} zeigt wie auf einen solchen \IC{Stream} gehorcht werden kann.
\ifIncludeFigures
  \begin{listing}[ht]
    \begin{minted}[]{dart}
var countStream = Stream<num>.periodic(const Duration(seconds: 1), (count) {
    return count;
  });

  countStream.listen((count) {
    print("Gezählte Sekunden: $count");
  });
\end{minted}
    \caption[Abhören eines \enquote{Streams}]{Abhören eines \enquote{Streams}, Quelle: Eigenes Listing}
    \label{lst:countStream}
  \end{listing}
\fi

Der \IC{countStream} liefert jede Sekunde einen neuen Wert, nämlich die aktuelle Sekunde -- von \enquote{0} beginnend.
Mit \IC{countStream.listen} kann eine Funktion übergeben werden, die immer dann ausgeführt wird, wenn dem \IC{countStream} ein neuer Wert hinzugefügt wurde.
Der erste Parameter \IC{count} ist dabei der hinzugefügte Wert.



Es wird zwischen zwei Arten von \enquote{Streams} unterschieden.
Solche, die genau einen Empfänger haben -- \enquote{single subscription streams} -- und solche, die beliebig viele Empfänger haben können -- \enquote{broadcast streams}.

Für die Formularanwendung sind ausschließlich \enquote{broadcast streams} zu berücksichtigen.
Die \enquote{Streams} sollen verwendet werden, um Änderungen in der Eingabemaske zu behandeln.
Die  Oberflächenelemente horchen auf diese Änderungen.
Teile der Oberfläche und damit die Oberflächenelemente, welche auf die \enquote{Streams} horchen, werden immer wieder neu gezeichnet.
Dabei werden die Elemente entfernt und durch neu konstruierte ersetzt.
So melden sich immer wieder Zuhörer vom \enquote{Stream} ab und neue Elemente melden sich an.
Aufgrund dessen kommen nur \enquote{broadcast streams} infrage.


