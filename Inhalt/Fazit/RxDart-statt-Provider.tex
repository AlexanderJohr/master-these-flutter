 
\section{Reevaluation des Zustandsmanagements}
\label{sec:Reevaluation-des-Zustandsmanagements}


Während der Implementierung wurde eine passende Vorgehensweise gesucht,
um den Zustand der Applikation zu verwalten
und damit die Aktualisierung der Oberfläche auszulösen.
Für simple Applikationen empfiehlt Google, den integrierten Mechanismus der \enquote{StatefulWidgets} und deren Methode \enquote{setState} zu verwenden \footcite[Vgl.][]{AddingInteractivityToYourFlutterApp}.
Doch durch die hohe Anzahl der Oberflächenelemente in der finalen Applikation ist diese Vorgehensweise nicht empfehlenswert.
Sie setzt das Aktualisieren gesamter \enquote{Widgets} bei Anpassung des Zustandes voraus,
was für die Laufzeitgeschwindigkeit die intensivste Belastung darstellt.
Stattdessen wurde versucht,
einen Mechanismus zu verwenden,
der es erlaubt,
nur Teile der Oberfläche neu zu zeichnen,
die wirklich eine Aktualisierung benötigen.

Zu diesem Zweck empfiehlt Google das Nutzen des Pakets \enquote{provider} der \enquote{Flutter}-Community \footcite[Vgl.][]{ProviderARecommendedApproach}.
Dieser Ansatz wurde in der Implementierung ursprünglich verwendet.
Das Paket hat den Nachteil,
dass für jeden Zustand,
der die Aktualisierung eines Teils der Oberfläche bewirken soll,
eine neue Klasse erstellt werden muss, die von \IC{ChangeNotifier} erbt.
Eine Möglichkeit ist,
dass jede dieser Klassen den nötigen Boilerplate-Quellcode enthält,
welcher die Oberfläche über die Methode \IC{notifyListeners} benachrichtigt.
Eine andere Möglichkeit ist es, für den gleichen Datentyp den benötigten Boilerplate-Code in einer eigenen Basisklasse auszulagern
und dann von dieser Klasse zu erben, wie in Listing \ref{lst:ChoiceChangeNotifier} zu sehen ist.
\ifIncludeFigures
  \begin{listing}[h]
    \begin{minted}[]{dart}
class ChoiceChangeNotifier extends ChangeNotifier {
    BuiltSet<Choice> _choices = BuiltSet<Choice>();

    BuiltSet<Choice> get choices => _choices;

    set choices(BuiltSet<Choice> choices) {
        _choices = choices;
        notifyListeners();
    }
}
class LetzterStatusViewModel extends ChoiceChangeNotifier {}
\end{minted}
    \caption[Verwendung der Klasse \enquote{ChangeNotifier}]{Verwendung der Klasse \enquote{ChangeNotifier}, Quelle: Eigenes Listing}
    \label{lst:ChoiceChangeNotifier}
  \end{listing}
\fi
\IC{ChoiceChangeNotifier} verwaltet den internen privaten Zustand \IC{_choices} \Z{3} über die öffentlichen Schnittstellen zum Lesen \Z{4} und Schreiben \Z{6-9}.
Bei Aktualisierung des Wertes erhalten alle \enquote{Listener} eine Benachrichtigung \Z{8}.
\IC{LetzterStatusViewModel} erbt dieses Verhalten, doch hat die Klasse darüber hinaus keine Implementierung.

Anschließend muss jeder \IC{ChangeNotifier} als ein \IC{ChangeNotifierProvider} registriert werden \LstZ{\ref{lst:MultiProvider}}{7}. 
Der \IC{MultiProvider} kann genutzt werden, um mehrere Provider in einer Liste zu übergeben.
Dort werden auch andere Services wie etwa \IC{MassnahmenFormViewModel} \Z{3} und \IC{MassnahmenModel} \Z{6} hinterlegt.

\ifIncludeFigures
  \begin{listing}[h]
    \begin{minted}[]{dart}
MultiProvider(
  providers: [
    Provider<MassnahmenFormViewModel>(create: (_) => MassnahmenFormViewModel()),
    Provider<MassnahmenJsonFile>(create: (_) => MassnahmenJsonFile()),
    Provider(
        create: (context) => MassnahmenModel(
            Provider.of<MassnahmenJsonFile>(context, listen: false))),
    ChangeNotifierProvider(create: (context) => LetzterStatusViewModel())),
  ],
  child: MaterialApp(),
)
\end{minted}
    \caption[Die \enquote{Widgets} \enquote{Provider}, \enquote{ChangeNotifierProvider} und \enquote{MultiProvider}]{Die \enquote{Widgets} \enquote{Provider}, \enquote{ChangeNotifierProvider} und \enquote{MultiProvider}, Quelle: Eigenes Listing}
    \label{lst:MultiProvider}
  \end{listing}
\fi

Dann ist der \IC{ChangeNotifier} in dem \enquote{Widget}, welches dem Parameter \IC{child} übergeben wird, und darüber hinaus in allen Kinderelementen dieses \enquote{Widgets} verfügbar.
Über einen \IC{Consumer} kann in der Oberfläche auf Änderungen des \IC{ChangeNotifier} reagiert werden \Lst{\ref{lst:Consumer}}.

\ifIncludeFigures
  \begin{listing}[h]
    \begin{minted}[]{dart}
  Consumer<LetzterStatusViewModel>(
      builder: (context, choiceChangeNotifier, child) {
      },
    )
\end{minted}
    \caption[Das \enquote{Widget} \enquote{Consumer}]{Das \enquote{Widget} \enquote{Consumer}, Quelle: Eigenes Listing}
    \label{lst:Consumer}
  \end{listing}
\fi


Doch diese Vorgehensweise bietet im Vergleich zu den von \enquote{Flutter} mitgelieferten \enquote{Widgets} keine Vorteile.
Das Äquivalent zum \IC{Consumer} ist das mitgelieferte \enquote{Widget} \IC{StreamBuilder},
welches mit jeder Art von \enquote{Stream} verwendet werden kann.

Damit unterstützt es ein breiteres Spektrum von Einsatzmöglichkeiten.
Beispielsweise kann ein transformierter \enquote{Stream} übergeben werden, wie im Kapitel \ref{chap:Schritt-4} gezeigt wird.

Die einzige fehlende Komponente dafür ist ein \enquote{Stream},
der den zuletzt übermittelten Wert speichert und allen neuen zuhörenden \IC{StreamBuilder}-Elementen übermittelt.
Deshalb wurde sich für das Package \enquote{RxDart} entschieden,
welches genau dieses Verhalten mit dem \enquote{BehaviorSubject} abdeckt.
Durch dessen Verwendung kann sowohl auf das Registrieren des \IC{ChangeNotifierProvider} verzichtet werden
und es muss keine weitere Klasse für die einzelnen beobachtbaren Objekte erstellt werden.

Auch der \IC{MultiProvider} erscheint auf den ersten Blick als sehr nützlich.
Doch das Anbieten der Services durch ein eigens implementiertes \IC{InheritedWidget} erlaubt einen Zugriff,
der kürzer und expliziter ist.
Durch die Umstellung konnte der Zugriff auf das \enquote{ViewModel} mithilfe des Ausdrucks \IC{Provider.of<MassnahmenFormViewModel>(context, listen: false)} durch \IC{AppState.of(context).viewModel} ersetzt werden.

Eine ganz ähnliche, wenn auch deutlich kompliziertere Variante dieser Vorgehensweise wurde auf der Google I/O 2018 von Filip Hracek und Matt Sullivan vorgestellt.
Doch anstatt lediglich das \IC{BehaviorSubject} für das \enquote{ViewModel} zu verwenden,
sorgte die Präsentation durch den zusätzlichen -- jedoch überflüssigen -- Einsatz zweier weiterer \enquote{Stream}-Klassen für schweres Verständnis \Lst{\ref{lst:CartBloc}}\footcite[][TC: \href{https://youtu.be/RS36gBEp8OI?t=1657}{27:37}]{GoogleIO18}.

\ifIncludeFigures
  \begin{listing}[h]
    \begin{minted}[]{dart}
class CartBloc{
    final _cart = Cart();

    Sink<Product> get addition => _additionalController.sink;

    final _additionController = StreamController<Product>();

    Stream<int> get itemCount => _itemCountSubject.stream;

    final _itemCountSubject = BehaviorSubject<int>();

    CartBloc(){
        _additionaController.stream.listen(_handle);
    }

    void _handle(Product product){
        _cart.add(product);
        _itemCountSubject.add(_cart.itemCount);
    }
}
\end{minted}
    \caption[Die Klasse \enquote{CartBloc}]{Die Klasse \enquote{CartBloc}, Quelle: \cite{GoogleIO18} TC: \href{https://youtu.be/RS36gBEp8OI?t=1657}{27:37}}
    \label{lst:CartBloc}
  \end{listing}
\fi

Der Quelltext setzt einige Grundlagen voraus.
Der \IC{Stream} ist als Teil der Datenübertragung zu identifizieren,
der die Nachrichten empfängt.
Über die Methode \IC{listen} können die eintreffenden Ereignisse behandelt werden.
Der \IC{Sink} ist dagegen als der Teil zu sehen,
welchem die Nachrichten zugestellt werden.
Die Methode \IC{add} erlaubt es,
eine neue Nachricht zu senden.
Ein \IC{StreamController} verwaltet sowohl den Übermittler als auch den Empfänger
und stellt beide über die \enquote{Getter}-Methoden \IC{sink} und \IC{stream} zur Verfügung.
Durch den Einsatz von \IC{BehaviorSubject} kann jedoch auf die drei Klassen verzichtet werden.
Ein Objekt der Klasse \IC{BehaviorSubject} vereint nicht nur das Senden und Empfangen von Nachrichten,
sondern speichert überdies den zuletzt gesendeten Wert für neu dazukommende Zuhörer ab.
Im Quelltext wurde ein Objekt des Typs \IC{Sink} verwendet,
um Ereignisse von dem \enquote{View} an das \enquote{ViewModel} senden zu können \Z{4}.
Der dazugehörige \IC{StreamController} wird in Zeile 6 erstellt.
Sobald ein Ereignis eintrifft,
so wird es dem \enquote{Model} \IC{_cart} hinzugefügt \Z{17}.
Es existiert außerdem ein weiterer \IC{Stream itemCount} \Z{8},
 welcher lediglich die transitive Eigenschaft der Anzahl der hinzugefügten Elemente bereitstellt \Z{18}.
Er nutzt das \IC{BehaviorSubject} mit dem Namen \IC{_itemCountSubject} \Z{10},
verwendet allerdings keine der für die Klasse einzigartigen Eigenschaften
-- wie zum Beispiel die \enquote{Getter}-Methode \IC{value} für den zuletzt übermittelten Wert.
Die Eigenschaften werden auch nicht anderen Klassen angeboten, da \IC{_itemCountSubject} nicht öffentlich ist.
Der \enquote{Stream} \IC{itemCount} könnte genauso gut durch einen weiteren \IC{StreamController} ersetzt werden.

Der gesamte Quellcode kann stark vereinfacht werden \Lst{\ref{lst:CartBlocVereinfacht}}.
\ifIncludeFigures
  \begin{listing}[h]
    \begin{minted}[]{dart}
class CartBloc{
  final _cart = BehaviorSubject<Cart>(seedValue: Cart());

  addProduct(Product product) => _cart.value = _cart.value..add(product);

  Stream<int> get itemCount => _cart.map((cart) => cart.itemCount);
}
\end{minted}
    \caption[Die vereinfachte Klasse CartBloc]{Die vereinfachte Klasse CartBloc, Quelle: Eigenes Listing}
    \label{lst:CartBlocVereinfacht}
  \end{listing}
\fi

Durch Einsatz der für das \IC{BehaviorSubject} einzigartigen \enquote{Getter}-Methode \IC{value} kann dem \enquote{Stream} ein neues Objekt hinzugefügt werden,
wodurch er gleichzeitig ein neues Ereignis sendet \Z{4}.
Die Zuweisung hat auf den Wert, welcher durch das \IC{BehaviorSubject} verwaltet wird, keinen Effekt, denn \IC{Cart} ist ein Referenztyp und kein Wertetyp.
Die Änderung an dem Wert war mit dem Methodenaufruf \IC{..add(product)} bereits abgeschlossen,
denn sie wurde am Original-Objekt durchgeführt, anstatt -- wie im Falle eines Wertetypen -- an einer Kopie des Objektes.
Mit der Zuweisung \IC{_cart.value = _cart.value} wird der \enquote{Getter}-Methode dieselbe Referenz zugewiesen,
welche zuvor bereits gespeichert war.
In diesem Fall wird sich zunutze gemacht, dass jede Zuweisung zur \enquote{Getter}-Methode \IC{value} ein neues Ereignis auslöst,
ungeachtet dessen, ob der Wert derselbe ist.
Die Erstellung weiterer \IC{StreamController} zum Senden der transitiven Eigenschaft \IC{itemCount} ist nicht nötig.
Sendet das \IC{BehaviorSubject} \IC{_cart} ein neues Event \Z{4},
so wird auch die Methode \IC{map} ausgelöst und ein transformiertes Ereignis gesendet \Z{6}.

Durch eine Anleitung mit diesem Ergebnis könnten gegebenenfalls weitere Entwickler das \enquote{BloC-Pattern} dem Paket \enquote{provider} vorziehen.

